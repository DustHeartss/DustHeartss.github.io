<!-- build time:Tue Jun 04 2024 22:52:01 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://dustheartss.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://dustheartss.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://dustheartss.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Spring"><link rel="canonical" href="https://dustheartss.github.io/2024/04/30/Java/Spring/"><title>Spring - Java | DustHeart = = 心事浩茫连广宇，于无声处听惊雷。</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Spring</h1><div class="meta"><span class="item" title="创建时间：2024-04-30 21:11:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-04-30T21:11:00+08:00">2024-04-30</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>32k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:19</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">DustHeart</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604213534.png"></li><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604213620.png"></li><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604214152.png"></li><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604214118.png"></li><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604213553.png"></li><li class="item" data-background-image="https://image-1325881450.cos.ap-nanjing.myqcloud.com/20240604212951.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://dustheartss.github.io/2024/04/30/Java/Spring/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="岳宗宁"><meta itemprop="description" content="心事浩茫连广宇，于无声处听惊雷。, 变得更强！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h1 id="1springioc容器"><a class="anchor" href="#1springioc容器">#</a> 1.SpringIoC 容器</h1><h2 id="11springioc容器和容器实现"><a class="anchor" href="#11springioc容器和容器实现">#</a> 1.1SpringIoC 容器和容器实现</h2><ul><li><p><strong>1.1.1 SpringIoC 容器介绍</strong><br>Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430211317.png" alt=""></p><p>上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。</p></li><li><p><strong>1.1.2 SpringIoC 容器具体接口和实现类</strong><br><strong>SpringIoc 容器接口</strong>：<br><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是 SpringIoC 容器标准化超接口！<br><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li>更容易与 Spring 的 AOP 功能集成</li><li>消息资源处理（用于国际化）</li><li>特定于应用程序给予此接口实现，例如 Web 应用程序的 <code>WebApplicationContext</code></li></ul></li></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集！<br><strong>ApplicationContext 容器实现类</strong>：</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430211722.png" alt=""></p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取 Java 配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><ul><li><p><strong>1.1.3 SpringIoC 容器管理配置方式</strong><br>Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430211317.png" alt=""></p><p>Spring 框架提供了多种配置方式：XML 配置方式、注解方式和 Java 配置类方式</p><ol><li>XML 配置方式：是 Spring 框架最早的配置方式之一，通过在 XML 文件中定义 Bean 及其依赖关系、Bean 的作用域等信息，让 Spring IoC 容器来管理 Bean 之间的依赖关系。该方式从 Spring 框架的第一版开始提供支持。</li><li>注解方式：从 Spring 2.5 版本开始提供支持，可以通过在 Bean 类上使用注解来代替 XML 配置文件中的配置信息。通过在 Bean 类上加上相应的注解（如 @Component, @Service, @Autowired 等），将 Bean 注册到 Spring IoC 容器中，这样 Spring IoC 容器就可以管理这些 Bean 之间的依赖关系。</li><li><strong>Java 配置类</strong>方式：从 Spring 3.0 版本开始提供支持，通过 Java 类来定义 Bean、Bean 之间的依赖关系和配置信息，从而代替 XML 配置文件的方式。Java 配置类是一种使用 Java 编写配置信息的方式，通过 @Configuration、@Bean 等注解来实现 Bean 和依赖关系的配置。</li></ol></li></ul><p>为了迎合当下开发环境，我们将以<strong>配置类 + 注解方式</strong>为主！</p><h2 id="12-spring-ioc-di概念总结"><a class="anchor" href="#12-spring-ioc-di概念总结">#</a> 1.2 Spring IoC / DI 概念总结</h2><h3 id="ioc容器"><a class="anchor" href="#ioc容器">#</a> IoC 容器</h3><p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p><h3 id="iocinversion-of-control控制反转"><a class="anchor" href="#iocinversion-of-control控制反转">#</a> IoC（Inversion of Control）控制反转</h3><p>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是 “反转” 了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p><h3 id="di-dependency-injection-依赖注入"><a class="anchor" href="#di-dependency-injection-依赖注入">#</a> DI (Dependency Injection) 依赖注入</h3><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p><h2 id="13-spring-ioc-di-实现步骤"><a class="anchor" href="#13-spring-ioc-di-实现步骤">#</a> 1.3 Spring IoC / DI 实现步骤</h2><blockquote><p>我们总结下，组件交给 Spring IoC 容器管理，并且获取和使用的基本步骤！</p></blockquote><ol><li><strong>配置元数据（配置）</strong><br>配置元数据，既是编写交给 SpringIoC 容器管理组件的信息，配置方式有三种。<br>基于 XML 的配置元数据的基本结构：<br>&lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt;</li></ol><p>​ &lt;!-- collaborators and configuration for this bean go here --&gt;<br>​	&lt;/bean&gt;</p><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）创建的。<br>&lt;bean/&gt; 标签 == 组件信息声明<p></p><ul><li><code>id</code> 属性是标识单个 Bean 定义的字符串。</li><li><code>class</code> 属性定义 Bean 的类型并使用完全限定的类名。</li></ul><ol start="2"><li><p><strong>实例化 IoC 容器</strong><br>提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。<br>我们应该选择一个合适的容器实现类，进行 IoC 容器的实例化工作：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>获取 Bean（组件）</strong><br><code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索 bean 的实例。<br>允许读取 Bean 定义并访问它们，如以下示例所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取ioc容器的组件对象</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"><span class="comment">//使用组件对象</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure><p></p></li></ol><h1 id="2springioc实现xml"><a class="anchor" href="#2springioc实现xml">#</a> 2.SpringIoC 实现 (xml)</h1><h2 id="21-实验一-组件bean信息声明配置ioc"><a class="anchor" href="#21-实验一-组件bean信息声明配置ioc">#</a> 2.1 实验一： 组件（Bean）信息声明配置（IoC）</h2><ol><li><p>目标<br>Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）。<br>我们学习，如何通过定义 XML 配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！</p></li><li><p>思路</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430212327.png" alt=""></p></li><li><p>准备项目</p><ol><li>创建 maven 工程（spring-ioc-xml-01）</li><li>导入 SpringIoC 相关依赖<br>pom.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>** 基于无参数构造函数 **</p></li></ol><blockquote><p>当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。</p></blockquote><ol><li><p>准备组件类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.ioc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HappyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认包含无参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HappyComponent.doWork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>xml 配置文件编写</p></li></ol><p>创建携带 spring 约束的 xml 配置文件</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430213730.png" alt=""></p><p>编写配置文件：<br>文件：resources/spring-bean-01.xml</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 实验一 [重要]创建bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;happyComponent&quot;</span> class=<span class="string">&quot;com.atguigu.ioc.HappyComponent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p></p><ul><li>bean 标签：通过配置 bean 标签告诉 IOC 容器需要创建对象的组件信息</li><li>id 属性：bean 的唯一标识，方便后期获取 Bean！本质是 map 中的 key</li><li>class 属性：组件类的全限定符！(全类名)</li><li>注意：要求当前组件类必须包含无参数构造函数！</li></ul><ol start="5"><li>** 基于静态工厂方法实例化 **</li></ol><blockquote><p>除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建 Bean 的配置 ！</p></blockquote><ol><li><p>准备组件类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> clientService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>xml 配置文件编写</p></li></ol><p>文件：resources/spring-bean-01.xml<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>class 属性：指定工厂类的全限定符！</li><li>factory-method: 指定静态工厂方法，注意，该方法必须是 static 方法。</li></ul><ol start="6"><li>** 基于实例工厂方法实例化 **</li></ol><blockquote><p>接下来我们讲解下如何定义使用实例工厂方法创建 Bean 的配置 ！</p></blockquote><ol><li><p>准备组建类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientServiceImpl</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ClientServiceImpl <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clientService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>xml 配置文件编写</p></li></ol><p>文件：resources/spring-bean-01.xml<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将工厂类进行ioc配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>factory-bean 属性：指定当前容器中工厂 Bean 的名称。(id)</li><li>factory-method: 指定实例工厂方法名。注意，实例方法必须是非 static 的！</li></ul><ol start="7"><li>图解 IoC 配置流程<br><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430212454.png" alt=""></li></ol><h2 id="22实验二组件bean-依赖注入配置di"><a class="anchor" href="#22实验二组件bean-依赖注入配置di">#</a> 2.2 实验二：组件 (Bean) 依赖注入配置 (DI)</h2><ol><li><p>目标<br>通过配置文件，实现 IoC 容器中 Bean 之间的引用（依赖注入 DI 配置）。<br>主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p></li><li><p>思路<br><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430212527.png" alt=""></p></li><li><p>基于构造函数的依赖注入（单个构造参数）</p></li><li><p>介绍<br>基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。<br>下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p></li><li><p>准备组件类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>编写配置文件</p></li></ol><p>文件：resources/spring-02.xml<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 构造函数引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>constructor-arg 标签：可以引用构造参数 ref 引用其他 bean 的标识。</li></ul><ol start="4"><li>基于构造函数的依赖注入（多构造参数解析）<ol><li><p>介绍<br>基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。<br>下面的示例演示通过构造函数注入多个参数，参数包含其他 bean 和基本数据类型！</p></li><li><p>准备组件类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="type">int</span> age , String name ,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>准备组件类<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 </span></span><br><span class="line"><span class="comment">           index从0开始 构造函数(0,1,2....)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p></li></ol></li></ol><ul><li>constructor-arg 标签：指定构造参数和对应的值</li><li>constructor-arg 标签：name 属性指定参数名、index 属性指定参数角标、value 属性指定普通属性值</li></ul><ol start="5"><li>基于 Setter 方法依赖注入<ol><li><p>介绍<br>开发中，除了构造函数注入（DI）更多的使用的 Setter 方法进行注入！<br>下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p></li><li><p>准备组件类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class MovieFinder&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String movieName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieName</span><span class="params">(String movieName)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.movieName = movieName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>编写配置文件<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMovieLister&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- setter方法，注入movieFinder对象的标识id</span></span><br><span class="line"><span class="comment">       name = 属性名  ref = 引用bean的id值</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;movieFinder&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- setter方法，注入基本数据类型movieName</span></span><br><span class="line"><span class="comment">       name = 属性名 value= 基本类型值</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;消失的她&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.MovieFinder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p></p></li></ol></li></ol><ul><li>property 标签： 可以给 setter 方法对应的属性赋值</li><li>property 标签： name 属性代表<strong> set 方法标识</strong>、ref 代表引用 bean 的标识 id、value 属性代表基本属性值</li></ul><p><strong>总结：</strong><br>依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为 setter 方法注入和构造函数注入，两种注入语法都需要掌握！<br>需要特别注意：引用其他 bean，使用 ref 属性。直接注入基本类型值，使用 value 属性。</p><h2 id="23实验三ioc容器创建和使用"><a class="anchor" href="#23实验三ioc容器创建和使用">#</a> 2.3 实验三：IoC 容器创建和使用</h2><ol><li><p>介绍<br>上面的实验只是讲解了如何在 XML 格式的配置文件编写 IoC 和 DI 配置！<br>如图：</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430211317.png" alt=""></p><p>想要配置文件中声明组件类信息真正的进行实例化成 Bean 对象和形成 Bean 之间的引用关系，我们需要声明 IoC 容器对象，读取配置文件，实例化组件和关系维护的过程都是在 IoC 容器中实现的！</p></li><li><p>容器实例化<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1:实例化并且指定配置文件</span></span><br><span class="line"><span class="comment">//参数：String...locations 传入一个或者多个配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">           </span><br><span class="line"><span class="comment">//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  </span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();   </span><br><span class="line"><span class="comment">//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置</span></span><br><span class="line">iocContainer1.setConfigLocations(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//后配置的文件,需要调用refresh方法,触发刷新配置</span></span><br><span class="line">iocContainer1.refresh();</span><br></pre></td></tr></table></figure><p></p></li><li><p>Bean 对象读取<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1: 根据id获取</span></span><br><span class="line"><span class="comment">//没有指定类型,返回为Object,需要类型转化!</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> </span><br><span class="line">        (HappyComponent) iocContainer.getBean(<span class="string">&quot;bean的id标识&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//使用组件对象        </span></span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2: 根据类型获取</span></span><br><span class="line"><span class="comment">//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理</span></span><br><span class="line"><span class="comment">//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> iocContainer.getBean(HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3: 根据id和类型获取</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;bean的id标识&quot;</span>, HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line">根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <span class="keyword">instanceof</span> 指定的类型』的返回结果，</span><br><span class="line">只要返回的是<span class="literal">true</span>就可以认定为和类型匹配，能够获取到。</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="24实验五高级特性factorybean特性和使用"><a class="anchor" href="#24实验五高级特性factorybean特性和使用">#</a> 2.4 实验五：高级特性：FactoryBean 特性和使用</h2><ol><li>FactoryBean 简介<br><code>FactoryBean</code> 接口是 Spring IoC 容器实例化逻辑的可插拔性点。(标准化组件工厂)<br>用于配置复杂的 Bean 对象，可以将创建过程存储在 <code>FactoryBean</code> 的 getObject 方法！<br><code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</li></ol><ul><li><code>T getObject()</code> :<br>返回此工厂创建的对象的实例。该返回值会被存储到 IoC 容器！</li><li><code>boolean isSingleton()</code> :<br>如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code> ，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code> （注意，lombok 插件使用，可能影响效果）。</li><li><code>Class&lt;?&gt; getObjectType()</code> : 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code> 。</li></ul><p>注：适用于没有办法直接实例化对象的 (不能 new 出来的，也不是工厂方法 例如 myBatis 整合和 Connection 的创建)</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430212633.png" alt=""></p><ol start="2"><li><p>FactoryBean 使用场景</p><ol><li>代理类的创建</li><li>第三方框架整合</li><li>复杂对象实例化等</li></ol></li><li><p>Factorybean 应用</p><ol><li><p>准备 FactoryBean 实现类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现FactoryBean接口时需要指定泛型</span></span><br><span class="line"><span class="comment">// 泛型类型就是当前工厂要生产的对象的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HappyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;HappyMachine&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String machineName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMachineName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> machineName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMachineName</span><span class="params">(String machineName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.machineName = machineName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HappyMachine <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 方法内部模拟创建、设置一个对象的复杂过程</span></span><br><span class="line">        <span class="type">HappyMachine</span> <span class="variable">happyMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyMachine</span>();</span><br><span class="line">    </span><br><span class="line">        happyMachine.setMachineName(<span class="built_in">this</span>.machineName);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> happyMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回要生产的对象的类型</span></span><br><span class="line">        <span class="keyword">return</span> HappyMachine.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>配置 FactoryBean 实现类<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- FactoryBean机制 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;happyMachine7&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.ioc.HappyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;machineName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;iceCreamMachine&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>测试读取 FactoryBean 和 FactoryBean.getObject 对象<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExperiment07</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">iocContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-bean-07.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象</span></span><br><span class="line">    <span class="type">HappyMachine</span> <span class="variable">happyMachine</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;happyMachine7&quot;</span>,HappyMachine.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;happyMachine = &quot;</span> + happyMachine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可!  &amp;happyMachine7 这是一种固定的约束</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;&amp;happyMachine7&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;bean = &quot;</span> + bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol></li><li><p>FactoryBean 和 BeanFactory 区别<br>**FactoryBean ** 是 Spring 中一种特殊的 bean，可以在 getObject () 工厂方法自定义的逻辑创建 Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject () 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。<br>一般情况下，整合第三方框架，都是通过定义 FactoryBean 实现！！！<br><strong>BeanFactory</strong> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean () 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。<br>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。</p></li></ol><h1 id="补充"><a class="anchor" href="#补充">#</a> 补充</h1><h2 id="ioc的生命周期和作用域"><a class="anchor" href="#ioc的生命周期和作用域">#</a> IoC 的生命周期和作用域</h2><ul><li>生命周期分为初始化 <code>init</code> 和销毁 <code>destory</code></li></ul><p>方法声明：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放资源逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>配置实现：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.BeanOne&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.BeanTwo&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>作用域 <code>scope</code> 作用是决定创建多少个 Bean 的实例对象。<ul><li>可选属性： <code>singleton</code> (单例模式)、 <code>prototype</code> (多例模式)</li></ul></li></ul><p>配置实现：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean的作用域 </span></span><br><span class="line"><span class="comment">    准备两个引用关系的组件类即可！！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;happyMachine8&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.ioc.HappyMachine&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;machineName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;happyMachine&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;happyComponent8&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.ioc.HappyComponent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;componentName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;happyComponent&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h1 id="3springioc和di依赖注入注解方式"><a class="anchor" href="#3springioc和di依赖注入注解方式">#</a> 3.SpringIoC 和 DI 依赖注入 (注解方式)</h1><h2 id="31将组件放入ioc容器基于三层架构常用注解"><a class="anchor" href="#31将组件放入ioc容器基于三层架构常用注解">#</a> 3.1 将组件放入 IoC 容器 (基于三层架构常用注解)</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component</td></tr><tr><td>相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component</td></tr><tr><td>相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如 SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component</td></tr><tr><td>相同。</td></tr></tbody></table><p>注：注解的属性 value 对应 bean 中的 id 不写 默认为类名首字母小写</p><h2 id="32组件bean作用域和生命周期"><a class="anchor" href="#32组件bean作用域和生命周期">#</a> 3.2 组件 (Bean) 作用域和生命周期</h2><p>生命周期： <code>@PostConstruct</code> (初始化方法) <code>@PreDestroy</code> (销毁方法)<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span></span><br><span class="line">  <span class="meta">@PostConstruct</span>  <span class="comment">//注解制指定初始化方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PreDestroy</span> <span class="comment">//注解指定销毁方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放资源逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>作用域： <code>@Scope</code> 选择对应常量即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="comment">//单例,默认值</span></span><br><span class="line"><span class="meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">//多例  二选一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span></span><br><span class="line">  <span class="meta">@PostConstruct</span>  <span class="comment">//注解制指定初始化方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="33bean属性赋值引用类型自动装配di"><a class="anchor" href="#33bean属性赋值引用类型自动装配di">#</a> 3.3Bean 属性赋值：引用类型自动装配 (DI)</h2><ul><li><code>@Autowired</code> + <code>@Qualifier</code> ：此注解为 Spring 提供<ul><li>默认通过 byType 方式在 IoC 中查找，如果没找到加 <code>@Qualifier(value=&quot;id名&quot;)</code> 通过 byName 查找</li></ul></li><li><code>@Rescource</code> ：此注解为 Java 提供 JSR-250 （需要导包）(JDK8-JDK11 不需要导包)<ul><li>属性有 name、type。默认通过 byName 方式查找，如果此方式没有找到，再通过 byType 查找。都没找到则报错</li></ul></li></ul><p>注：简单来说，<strong>byName 就是变量名去匹配 bean 的 id 属性，而 byType 则是变量类型去匹配 bean 的 class 属性</strong><br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p></p><h2 id="34bean属性赋值基本类型属性自动装配di"><a class="anchor" href="#34bean属性赋值基本类型属性自动装配di">#</a> 3.4Bean 属性赋值：基本类型属性自动装配 (DI)</h2><ul><li><code>@Value</code> ： 通常用于注入外部化属性</li></ul><p><strong>声明外部配置</strong><br>application.properties<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catalog.name=MovieCatalog</span><br></pre></td></tr></table></figure><br><strong>xml 引入外部配置</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入外部配置文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">&quot;application.properties&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><br>**@Value 注解读取配置 ** <code>**@Value(&quot;$&#123;对应的key:默认值&#125;&quot;)**</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.components;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.components</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 普通的组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情况1: $&#123;key&#125; 取外部配置key对应的值!</span></span><br><span class="line"><span class="comment">     * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;catalog:hahaha&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="4基于配置类方式管理bean"><a class="anchor" href="#4基于配置类方式管理bean">#</a> 4. 基于配置类方式管理 Bean</h1><h2 id="41完全注解开发"><a class="anchor" href="#41完全注解开发">#</a> 4.1 完全注解开发</h2><p>用配置类彻底取代 xml<br><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430212726.png" alt=""><br>具体实现：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="42引用第三方组件beanbean"><a class="anchor" href="#42引用第三方组件beanbean">#</a> 4.2 引用第三方组件 (Bean)@Bean</h2><p><strong>场景需求</strong>：将 Druid 连接池对象存储到 IoC 容器<br><strong>需求分析</strong>：第三方 jar 包的类，添加到 ioc 容器，无法使用 @Component 等相关注解！因为源码 jar 包内容为只读模式！<br><strong>xml 方式实现</strong>：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>配置类方式实现</strong>：<br><code>@Bean</code> 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML 配置的人来说， <code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code> 元素起着相同的作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入jdbc.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span></span><br><span class="line">    <span class="comment">//解决方案: xml方式可以使用&lt;bean标签</span></span><br><span class="line">    <span class="comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Java代码实例化</span></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        <span class="comment">//返回结果即可</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="43bean注解细节"><a class="anchor" href="#43bean注解细节">#</a> 4.3@Bean 注解细节</h2><p>@Bean 注解源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="comment">//前两个注解可以指定Bean的标识</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。</span></span><br><span class="line">    <span class="comment">//autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，</span></span><br><span class="line">    <span class="comment">//可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定初始化方法</span></span><br><span class="line">    String <span class="title function_">initMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//指定销毁方法</span></span><br><span class="line">    String <span class="title function_">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;(inferred)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>指定 @Bean 名称 默认是当前方法名 == &lt;bean 中的 id</li></ul><p><code>@Bean(name=自定义)</code> 或者 <code>@Bean(value=自定义)</code></p><ul><li><p>初始化和销毁方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// initialization logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// destruction logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> BeanOne <span class="title function_">beanOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanOne</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> BeanTwo <span class="title function_">beanTwo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanTwo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>作用域和原来一样加 <code>@Scope</code></p></li></ul><p>@Bean 方法之间的调用（通过形参列表）<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.config;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.ioc.HappyComponent;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.ioc.HappyMachine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.config</span></span><br><span class="line"><span class="comment"> * description: 配置HappyComponent和HappyMachine关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HappyMachine <span class="title function_">happyMachine</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HappyMachine</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以直接在形参列表接收IoC容器中的Bean!</span></span><br><span class="line"><span class="comment">     *    情况1: 直接指定类型即可</span></span><br><span class="line"><span class="comment">     *    情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称!</span></span><br><span class="line"><span class="comment">     *           例如:</span></span><br><span class="line"><span class="comment">     *               <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     *               public Foo foo1()&#123;</span></span><br><span class="line"><span class="comment">     *                   return new Foo();</span></span><br><span class="line"><span class="comment">     *               &#125;</span></span><br><span class="line"><span class="comment">     *               <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     *               public Foo foo2()&#123;</span></span><br><span class="line"><span class="comment">     *                   return new Foo()</span></span><br><span class="line"><span class="comment">     *               &#125;</span></span><br><span class="line"><span class="comment">     *               <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     *               public Component component(Foo foo1 / foo2 通过此处指定引入的bean)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HappyComponent <span class="title function_">happyComponent</span><span class="params">(HappyMachine happyMachine)</span>&#123;</span><br><span class="line">        <span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyComponent</span>();</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        happyComponent.setHappyMachine(happyMachine);</span><br><span class="line">        <span class="keyword">return</span> happyComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="44import"><a class="anchor" href="#44import">#</a> 4.4@Import</h2><p><code>@Import(要引用配置类的.class)</code><br>作用：可以在一个配置类中 ( <code>@Configuration</code> ) 引用另一个配置类</p><h1 id="5spring-aop"><a class="anchor" href="#5spring-aop">#</a> 5.Spring AOP</h1><h2 id="51aop术语名词介绍"><a class="anchor" href="#51aop术语名词介绍">#</a> 5.1AOP 术语名词介绍</h2><p>1 - 横切关注点<br>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。<br>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<br><img data-src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img007.9ad7afe5.png#id=evZS0&amp;originHeight=631&amp;originWidth=1219&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。<br>2 - 通知 (增强)<br>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法前执行 <code>@Before(切点表达式)</code></li><li>返回通知：在被代理的目标方法成功结束后执行（<strong>寿终正寝</strong>） <code>@AfterReturing(切点表达式)</code></li><li>异常通知：在被代理的目标方法异常结束后执行（<strong>死于非命</strong>） <code>@AfterThrowing(切点表达式)</code></li><li>后置通知：在被代理的目标方法最终结束后执行（<strong>盖棺定论</strong>） <code>@After(切点表达式)</code></li><li>环绕通知：使用 try...catch...finally 结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 <code>@Around(切点表达式)</code></li></ul><p><img data-src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img008.ea600562.png#id=VWcsK&amp;originHeight=530&amp;originWidth=771&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">3 - 连接点 joinpoint<br>这也是一个纯逻辑概念，不是语法定义的。<br>指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法<br><img data-src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png#id=PTM8F&amp;originHeight=865&amp;originWidth=1350&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> 4 - 切入点 pointcut<br>定位连接点的方式，或者可以理解成被选中的连接点！<br>是一个表达式，比如 execution (_ com.spring.service.impl._.*(..))。符合条件的每个方法都是一个具体的连接点。<br>5 - 切面 aspect<br>切入点和通知的结合。是一个类。<br><img data-src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img009.a0b70cb3.png#id=ppmxu&amp;originHeight=531&amp;originWidth=771&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">6 - 目标 target<br>被代理的目标对象。<br>7 - 代理 proxy<br>向目标对象应用通知之后创建的代理对象。<br>8 - 织入 weave<br>指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring 采用后者。</p><h2 id="52aop实现"><a class="anchor" href="#52aop实现">#</a> 5.2AOP 实现</h2><ol><li>加入依赖</li></ol><p>因为 Spring-Context 会传递 Spring-aop， spring-aspects 传递 Aspectj。所以只需引入 spring-aspects 即可</p><ol start="2"><li><p>准备接口<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>纯净实现类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>声明切面类 ( <code>@Aspect</code> )<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line">    <span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>开启 aspectj 注解支持 <code>@EnableAspectJAutoProxy</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span></span><br><span class="line"><span class="comment">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="53获取通知细节信息joinpoint返回值异常"><a class="anchor" href="#53获取通知细节信息joinpoint返回值异常">#</a> 5.3 获取通知细节信息 (JoinPoint，返回值，异常)</h2><ol><li><strong>JointPoint 接口</strong><br>需要获取方法签名、传入的实参等信息时，可以在通知方法声明 JoinPoint 类型的形参。</li></ol><ul><li>要点 1：JoinPoint 接口通过 getSignature () 方法获取目标方法的签名（方法声明时的完整信息）</li><li>要点 2：通过目标方法签名对象获取方法名</li><li>要点 3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before注解标记前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span></span><br><span class="line"><span class="comment">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span></span><br><span class="line"><span class="comment">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通过JoinPoint对象获取目标方法签名对象</span></span><br><span class="line">    <span class="comment">// 方法的签名：一个方法的全部声明信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过方法的签名对象获取目标方法的详细信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">    System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.由于数组直接打印看不到具体数据，所以转换为List集合</span></span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] &quot;</span> + methodName + <span class="string">&quot;方法开始了，参数列表：&quot;</span> + argList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p><strong>方法返回值</strong><br>在返回通知中，通过 @AfterReturning** ** 注解的 <code>returning</code> 属性获取目标方法的返回值！<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        returning = &quot;targetMethodReturnValue&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>异常对象捕捉</strong><br>在异常通知中，通过 @AfterThrowing 注解的 <code>throwing</code> 属性获取目标方法抛出的异常对象<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="54切点表达式"><a class="anchor" href="#54切点表达式">#</a> 5.4 切点表达式</h2><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/image.png" alt=""></p><p>** 重用切点表达式 ** <code>@Pointcut(切点表达式)</code></p><ol><li><p>同一类内部引用<strong>提取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切入点表达式重用</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void declarPointCut() &#123;&#125;</span></span><br></pre></td></tr></table></figure><br>注意：提取切点注解使用 @Pointcut (切点表达式) ， 需要添加到一个</strong>无参数无返回值方法 ** 上即可！<br>引用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCoreOperation</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>其他类调用</p></li></ol><p>不同类在引用切点，只需要添加<strong>类的全限定符 + 方法名</strong>即可！<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">roundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="55环绕通知around"><a class="anchor" href="#55环绕通知around">#</a> 5.5 环绕通知 <code>@Around</code></h2><p>环绕通知对应整个 try...catch...finally 结构，包括前面四种通知的所有功能。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用@Around注解标明环绕通知方法</span></span><br><span class="line"><span class="meta">@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span></span><br><span class="line"><span class="params">        // Spring会将这个类型的对象传给我们</span></span><br><span class="line"><span class="params">        ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过签名对象获取目标方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明变量用来存储目标方法的返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetMethodReturnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法执行前：开启事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过ProceedingJoinPoint对象调用目标方法</span></span><br><span class="line">        <span class="comment">// 目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法成功返回后：提交事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法抛异常后：回滚事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，异常：&quot;</span> + e.getClass().getName());</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法最终结束后：释放数据库连接</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> targetMethodReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="56切面优先级设置order"><a class="anchor" href="#56切面优先级设置order">#</a> 5.6 切面优先级设置 <code>@Order</code></h2><p>使用 @Order 注解可以控制切面的优先级：</p><ul><li>@Order (较小的数)：优先级高</li><li>@Order (较大的数)：优先级低</li></ul><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/image%20(2).png" alt=""></p><h1 id="6spring声明式事务"><a class="anchor" href="#6spring声明式事务">#</a> 6.Spring 声明式事务</h1><h2 id="61概念"><a class="anchor" href="#61概念">#</a> 6.1 概念</h2><p>声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。<br>开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！<br>使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。<br>区别：</p><ul><li>编程式事务需要手动编写代码来管理事务</li><li>而声明式事务可以通过配置文件或注解来控制事务。</li></ul><h2 id="62-spring事务管理器"><a class="anchor" href="#62-spring事务管理器">#</a> 6.2 Spring 事务管理器</h2><ol><li><p>Spring 声明式事务对应依赖</p><ul><li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li><li>spring-jdbc: 包含 DataSource 方式事务管理器实现类 DataSourceTransactionManager</li><li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate/Jpa 等</li></ul></li><li><p>Spring 声明式事务对应事务管理器接口</p><p><img data-src="https://raw.githubusercontent.com/DustHeartss/images2/main/20240430214053.png" alt=""></p></li><li><p>我们现在要使用的事务管理器是 org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC 方式、JdbcTemplate 方式、Mybatis 方式的事务实现！<br>DataSourceTransactionManager 类中的主要方法：</p><ul><li>doBegin ()：开启事务</li><li>doSuspend ()：挂起事务</li><li>doResume ()：恢复挂起的事务</li><li>doCommit ()：提交事务</li><li>doRollback ()：回滚事务</li><li>doCellback():jian</li></ul></li></ol><h2 id="63实现"><a class="anchor" href="#63实现">#</a> 6.3 实现</h2><ol><li>配置事务管理器</li></ol><p>数据库相关配置<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.config</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 数据库和连接池配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponenScan(&quot;com.atguigu&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化dataSource加入到ioc容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;atguigu.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.driver&#125;&quot;)</span>String driver,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.username&#125;&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.password&#125;&quot;)</span>String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装配事务管理实现对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>使用声明式注解 <code>@Transactional</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><div class="tags"><a href="/tags/Spring/" rel="tag"><i class="ic i-tag"></i> Spring</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-04-30 21:41:15" itemprop="dateModified" datetime="2024-04-30T21:41:15+08:00">2024-04-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="岳宗宁 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="岳宗宁 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="岳宗宁 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>岳宗宁 <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://dustheartss.github.io/2024/04/30/Java/Spring/" title="Spring">https://dustheartss.github.io/2024/04/30/Java/Spring/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/04/30/Java/Maven/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;image-1325881450.cos.ap-nanjing.myqcloud.com&#x2F;20240604223946.png" title="Maven简介"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Maven简介</h3></a></div><div class="item right"><a href="/2024/04/30/Java/SpringMVC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;image-1325881450.cos.ap-nanjing.myqcloud.com&#x2F;20240604213256.png" title="SpringMVC"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>SpringMVC</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1springioc%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">1.SpringIoC 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11springioc%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1SpringIoC 容器和容器实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-spring-ioc-di%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Spring IoC &#x2F; DI 概念总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ioc%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">IoC 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iocinversion-of-control%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.2.2.</span> <span class="toc-text">IoC（Inversion of Control）控制反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#di-dependency-injection-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">DI (Dependency Injection) 依赖注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-spring-ioc-di-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Spring IoC &#x2F; DI 实现步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2springioc%E5%AE%9E%E7%8E%B0xml"><span class="toc-number">2.</span> <span class="toc-text">2.SpringIoC 实现 (xml)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%AE%9E%E9%AA%8C%E4%B8%80-%E7%BB%84%E4%BB%B6bean%E4%BF%A1%E6%81%AF%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AEioc"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 实验一： 组件（Bean）信息声明配置（IoC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E5%AE%9E%E9%AA%8C%E4%BA%8C%E7%BB%84%E4%BB%B6bean-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AEdi"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 实验二：组件 (Bean) 依赖注入配置 (DI)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E5%AE%9E%E9%AA%8C%E4%B8%89ioc%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 实验三：IoC 容器创建和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E5%AE%9E%E9%AA%8C%E4%BA%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7factorybean%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 实验五：高级特性：FactoryBean 特性和使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">3.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ioc%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.1.</span> <span class="toc-text">IoC 的生命周期和作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3springioc%E5%92%8Cdi%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">3.SpringIoC 和 DI 依赖注入 (注解方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E5%B0%86%E7%BB%84%E4%BB%B6%E6%94%BE%E5%85%A5ioc%E5%AE%B9%E5%99%A8%E5%9F%BA%E4%BA%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 将组件放入 IoC 容器 (基于三层架构常用注解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E7%BB%84%E4%BB%B6bean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 组件 (Bean) 作用域和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Ddi"><span class="toc-number">4.3.</span> <span class="toc-text">3.3Bean 属性赋值：引用类型自动装配 (DI)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Ddi"><span class="toc-number">4.4.</span> <span class="toc-text">3.4Bean 属性赋值：基本类型属性自动装配 (DI)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86bean"><span class="toc-number">5.</span> <span class="toc-text">4. 基于配置类方式管理 Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 完全注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6beanbean"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 引用第三方组件 (Bean)@Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43bean%E6%B3%A8%E8%A7%A3%E7%BB%86%E8%8A%82"><span class="toc-number">5.3.</span> <span class="toc-text">4.3@Bean 注解细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44import"><span class="toc-number">5.4.</span> <span class="toc-text">4.4@Import</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5spring-aop"><span class="toc-number">6.</span> <span class="toc-text">5.Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51aop%E6%9C%AF%E8%AF%AD%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">5.1AOP 术语名词介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52aop%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">5.2AOP 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E7%BB%86%E8%8A%82%E4%BF%A1%E6%81%AFjoinpoint%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BC%82%E5%B8%B8"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 获取通知细节信息 (JoinPoint，返回值，异常)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 切点表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5around"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 环绕通知 @Around</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AEorder"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 切面优先级设置 @Order</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.</span> <span class="toc-text">6.Spring 声明式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 Spring 事务管理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 实现</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/04/30/Java/Maven/" rel="bookmark" title="Maven简介">Maven简介</a></li><li class="active"><a href="/2024/04/30/Java/Spring/" rel="bookmark" title="Spring">Spring</a></li><li><a href="/2024/04/30/Java/SpringMVC/" rel="bookmark" title="SpringMVC">SpringMVC</a></li><li><a href="/2024/04/30/Java/SSM%E6%95%B4%E5%90%88/" rel="bookmark" title="SSM整合">SSM整合</a></li><li><a href="/2024/04/30/Java/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E2%80%94cookie%E3%80%81session%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="bookmark" title="会话管理">会话管理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="岳宗宁" data-src="/images/avatar.jpg"><p class="name" itemprop="name">岳宗宁</p><div class="description" itemprop="description">变得更强！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">1</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">5</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/04/30/Java/Maven/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/04/30/Java/SpringMVC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/04/30/Java/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/04/29/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/04/30/Java/SpringMVC/" title="SpringMVC">SpringMVC</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/04/30/Java/Maven/" title="Maven简介">Maven简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/04/30/Java/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E2%80%94cookie%E3%80%81session%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8/" title="会话管理">会话管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/04/30/Java/Spring/" title="Spring">Spring</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">岳宗宁 @ DustHeart</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">127k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:17</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/04/30/Java/Spring/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:320},mobile:{show:!0},log:!1})</script></body></html><!-- rebuild by hrmmi -->